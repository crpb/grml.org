<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN" "http://www.w3.org/TR/1999/REC-html401-19991224/loose.dtd"> 
<!-- Diese Seite untersteht dem Copyleft von Michael Prokop. Details unter http://www.michael-prokop.at/copyleft/ -->
<html>
<head>
<title>Computer - Tools - Zsh-Liebhaber-Seite @ Michael Prokop</title>
<meta name="Title" content="Michael Prokop - Homepage">
<meta name="Author" content="Michael Prokop">
<meta name="Revisit" content="After 7 days">
<meta name="Keywords" content="Michael, Prokop, Matthias, Kopfermann, Linux, Tools, Zsh, Zsh-Liebhaber-Seite, Shell, Bash">
<meta name="Description" content="Michael Prokops Homepage - Zsh-Liebhaber-Seite">
<meta name="Robots" content="index,follow">
<meta name="Language" content="german">
<meta name="identifier-url" content="http://www.michael-prokop.at/">
<meta http-equiv="imagetoolbar" content="no">
<link rel="stylesheet" href="/style.css" type="text/css">
</head>

<body bgcolor="#FFFFFF" text="#333333" link="#000099" vlink="#333333" alink="#FFCC00">
<script src="/infotext.js" type="text/javascript"></script>
<a name="oben"></a>
<table border="0" bgcolor="#FFCC00" cellpadding="0" cellspacing="0" width="100%" id="Navigation">
  <tr> 
    <td valign="top" width="24" height="59" rowspan="2"> 
      <img src="../images/corner_tl.png" width="17" height="17" align="left" hspace="0" alt="*">
    </td>
    <td valign="middle" colspan="2" nowrap height="59" rowspan="2"> 
      <div id="Layer1" style="position:absolute; width:404px; height:24px; z-index:1; left: 305px; top: 40px"> 
        <form name="tool" method="post" action="">
          <input type="text" name="tip" size="45">
        </form>
      </div>
      <a href="/"><img src="../images/bckgrd.png" width="719" height="68" alt="Zur Startseite" title="Zur Startseite" border="0"></a></td>
    <td colspan="2" height="71" valign="middle" rowspan="2">
    </td>
    <td align="right" height="41" valign="top"><img src="../images/corner_tr.png" width="17" height="17" align="right" hspace="0" alt="*"></td>
  </tr>
  <tr> 
    <td align="right" height="30" valign="top">&nbsp;</td>
  </tr>
  <tr> 
    <td valign="bottom" height="25" width="25" align="left"><img src="../images/corner_bl.png" width="17" height="17" align="left" alt="Navigation: " hspace="0"></td>
    <td colspan="3" nowrap height="19" valign="middle"> 
      <a href="../info/" onmouseover="showtip('Informationen zur Website')" onmouseout="showtip('')">Info</a>      
      <a href="../person/" onmouseover="showtip('Infos über mich, meine Arbeit, Interessen, ...')" onmouseout="showtip('')">Person</a>      
      <a href="../gallery/" onmouseover="showtip('Meine Foto-Galerie')" onmouseout="showtip('')">Gallery</a>     
      <a href="../computer/" onmouseover="showtip('Computertipps und interessante Artikel')" onmouseout="showtip('')">Computer</a>      
      <a href="../internet/" onmouseover="showtip('Allerlei zum Thema Internet und Webdesign')" onmouseout="showtip('')">Internet</a>      
      <a href="../fun/" onmouseover="showtip('Just4FUN! Sprüche, Witze,...')" onmouseout="showtip('')">Fun</a>     
      <a href="../sonstiges/" onmouseover="showtip('Wissenswertes, die perfekte Rede und Allerlei')" onmouseout="showtip('')">Sonstiges</a>      
      <a href="../sitemap/" onmouseover="showtip('Die Sitemap zum besseren Überblick')" onmouseout="showtip('')">Sitemap</a>      
      <a href="../cgi-bin/search.pl" onmouseover="showtip('Die Homepage www.michael-prokop.at durchsuchen')" onmouseout="showtip('')">Suche</a>      
      <a href="../kontakt/" onmouseover="showtip('Kontaktmöglichkeit')" onmouseout="showtip('')">Kontakt</a></td>
    <td height="25" valign="bottom" colspan="2"><img src="../images/corner_br.png" width="17" height="17" align="right" alt="*" hspace="0"></td>
  </tr>
</table>
        <br><div align="right">Computer</div>
          <div class="submenu" id="Navilinks">
             <div class="normal"><a href="index.html" title="Allgemein"
                                  onMouseOver="showtip('Überblick zu den Themen der Kategorie PC')"
                                  onMouseOut="showtip('')"
                                  >Allgemein</a></div>
             <div class="normal"><a href="laptop.html" title="Laptop" 
                                  onMouseOver="showtip('Linux Mini-HowTO zum Sony VAIO FX 602 Laptop')"
                                  onMouseOut="showtip('')"
                                  >Laptop</a></div>
             <div class="normal"><a href="../latex/" title="LaTeX"
                                  onMouseOver="showtip('LaTeX unter Linux und Windows - gvim')"
                                  onMouseOut="showtip('')"
                                  >LaTeX</a></div>
             <div class="normal"><a href="linux.html" title="Linux"
                                  onMouseOver="showtip('Allerlei zum Betriebssystem Linux')"
                                  onMouseOut="showtip('')"
                                  >Linux</a></div>
             <div class="normal"><a href="office.html" title="Office"
                                  onMouseOver="showtip('Allerlei zum Thema Office')"
                                  onMouseOut="showtip('')"
                                  >Office</a></div>
             <div class="normal"><a href="plan9.html" title="Plan 9"
                                  onMouseOver="showtip('Das Netzwerkbetriebssystem Plan 9')"
                                  onMouseOut="showtip('')"
                                  >Plan9</a></div>
             <div class="normal"><a href="psion.html" title="Psion"
                                  onMouseOver="showtip('Information zum Psion (Revo)')"
                                  onMouseOut="showtip('')"
                                  >Psion</a></div>
             <div class="normal"><a href="qnx.html" title="QNX"
                                  onMouseOver="showtip('Das Echtzeitbetriebssystem QNX')"
                                  onMouseOut="showtip('')"
                                  >QNX</a></div>
             <div class="selected"><a href="#" title="Tools"
                                  onMouseOver="showtip('Allerlei zu verschiedenen Tools/Software')"
                                  onMouseOut="showtip('')"
                                  >Tools</a></div>
             <div class="normal"><a href="windows.html" title="Windows"
                                  onMouseOver="showtip('Allerlei zum Betriebssystem Windows')"
                                  onMouseOut="showtip('')"
                                  >Windows</a></div>
          </div>
     <div class="page">     
           <div class="button"><a href="tools.html" title="Allerlei">Allerlei</a></div>
           <div class="button"><a href="tools_vim.html" title="vim">vim</a></div>
           <div class="button"><a href="tools_mutt.html" title="mutt">mutt</a></div>
           <div class="button"><a href="tools_slrn.html" title="slrn">slrn</a></div>
           <div class="button"><a class="active" href="#" title="zsh">zsh</a></div>
           <div class="button"><a href="tools_browser.html" title="Browser">browser</a></div>
           <div class="button"><a href="tools_icq.html" title="icq">icq</a></div>
           <div class="button"><a href="tools_screen.html" title="screen">screen</a></div>
           <p>&nbsp;</p>

           <p>Submenu:</p>
           <div class="subbutton"><a href="tools_zsh.html" title="mutt">Zsh - Generell</a></div>
           <div class="subbutton"><a class="subactive" href="#" title="zsh-liebhaber">Zsh-Liebhaber</a></div>
           <p>&nbsp;</p>

           <p class="index">Quick-Index</p>

           <p>
              <a class="smalllink" href="#vorwort">Vorwort</a> - 
              <a class="smalllink" href="#warum">Warum wurde diese Seite gemacht?</a> -
              <a class="smalllink" href="#faehigkeiten">Fähigkeiten die an der Zsh faszinieren</a> -
              <a class="smalllink" href="#lokaledateien">Lokale Dateien</a> -
              <a class="smalllink" href="#literatur">Literatur</a>
            </p>

        <h1>Die Zsh-Liebhaber-Seite
        <a href="http://www.michael-prokop.at/computer/tools_zsh_liebhaber.html">
        <img src="http://www.michael-prokop.at/images/zsh_liebhaber.png" alt="zsh liebhaber
        webpage"></a></h1>
        <strong><a href="tools_zsh_en.html">There exists an english webpage!</a></strong>

        <p>Take a look at the <a href="/computer/tools_zsh_en.html">zsh-lovers</a> project!</p>

        <h2><a name="vorwort"></a>Vorwort</h2>
 
        <p>Willkommen zur Zsh-Liebhaber-Seite! Diese Webpage war ursprünglich unter <a
        href="http://www.infodrom.north.de/~matthi/zsh/">www.infodrom.north.de/~matthi/zsh/</a>
        erreichbar. Gemeinsam mit Matthias Kopfermann habe ich (Michael) diese Webpage hierher
        verlagert, verbessert und aktualisiert.  Redundanzen zu <a href="tools_zsh.html">Zsh -
        Generell</a> sind durchaus möglich und nicht ungewollt. Über <a
        href="mailto:zsh-liebhaber@michael-prokop.at">Feedback an
        zsh-liebhaber@michael-prokop.at</a> freuen wir uns!</p>
        
<pre>
Begonnen:         Fre Okt 17 13:00:00 CET 1997
Zuletzt editiert: Sat Aug 14 12:20:29 CEST 2004
</pre>

        <p>Die Zsh (sprich Z-Shell) ist eine herausragende, aber im Verhältnis zur Bash
        ziemlich unbekannte Shell, also ein befehlsorientierter Eingabemechanismus, über den
        man vor allem Befehle unter Unix interaktiv eingeben und außerdem Befehle
        automatisieren und Abläufe programmieren kann. Sie ist im Falle der Zsh mit einer
        mächtigen Programmiersprache durchaus gleichzusetzen, wenn dabei auch kein
        Maschinencode erzeugt wird.</p>
        
        <h2><a name="warum"></a>Warum wurde diese Seite gemacht?</h2>

        <p>Wir halten die Zsh für herausragend in Benutzerfreundlichkeit und Mächtigkeit.  Sie
        macht das Arbeiten auf der Kommandozeile zur Freude, besticht durch ungeheure
        Anpassungsfähigkeit und hilft, wenn man sich einmal wieder nicht genau an irgendwelche
        Optionen bei Befehlen erinnere.  Zusätzlich kann sie vieles, was andere Shells nur
        durch externe Befehle möglich machen. Ich (Matthias) selber stieß beim Lesen der
        Linux-Gazette zum ersten Mal auf die Zsh. Ein Benutzer hatte dort in einer Email zum
        Thema "Umwandlung von großen Buchstaben von DOS-Dateien nach Linux" eine sehr einfache
        und kurze Lösung durch die Zsh berichtet (siehe unten).  Genau dafür ist die Zsh wie
        geschaffen. Man kann damit Probleme mit wenigen Tastenanschlägen lösen.</p>
        
        <p>Auf einer Homepage über unterschiedliche Shells las ich (Matthias), die Zsh könne
        wahrscheinlich mehr als der Autor selber <a
        href="http://www.int.gu.edu.au/courses/2010int/nscp_shells.html">wisse</a>. Natürlich
        hat das seinen Preis in der Größe der Shell und in der Größe des Handbuchs. Puristen
        werden die Zsh wohl nicht unbedingt benutzen. Aber wer sagt denn, dass man nicht in
        einer Sache Purist und in einer anderen sehr großzügig oder gar verschwenderisch sein
        kann oder dass man nicht für bestimmte Aufgaben so und für andere anders verfährt, je
        nach Bedarf, Speicherplatz, Rechnergeschwindigkeit?</p>
        
        <p> <a href="zsh.intro.ps.gz" >Hier</a> findet sich die  Beschreibung der Z-Shell vom
        ihrem ursprünglichen Autor Paul Falstad, der übrigens durch einen Zhong Shao (heute
        Professor in Yale) mit Benutzername <a
        href="http://groups.google.com/groups?selm=18499%40princeton.Princeton.EDU&amp;output=gplain">zsh</a>
        auf diesen Namen kam. :)</p>
        
        <p>Der ursprüngliche Autor beschrieb 1991 die Vorzüge dieser 1990 begonnenen Shell.
        Trotz seines Alters kann dieser längere Artikel Neugier wecken. Zumindest bei Sven
        Wischnowsky, einem der wichtigsten Zsh-Entwickler seit 1992 (ihm verdankt die Zsh ihre
        Vervollständigungsmechanismen und vieles mehr) und 1997 bei mir (Matthias) und 2002 bei
        mir (Michael) war der Artikel der Anlass, auf die Z-Shell umzusteigen. Und die Shell
        hat heutzutage noch so viele praktische Fähigkeiten dazu bekommen!</p>
        
        <p>Seit 1999 gibt es diesen neuen <a href="http://zsh.sunsite.dk/Guide/">Zsh-Guide</A>
        von Peter Stephenson, einem anderen wichtigen Entwickler der Z-Shell, der mit großer
        Liebe zum Detail, mit Witz und  - wie wir finden - sehr verständlich auf die Zsh und
        ihre Möglichkeiten eingeht und von dem in naher Zukunft sogar ein gedrucktes Buch über
        diese Shell erscheinen soll!</p>
        
        <p>Leider ist diese tolle Shell, die es gerade Anfängern so viel leichter machen könnte
        und Power-Usern eine Unzahl an Möglichkeiten bietet, z.B. in Linux-Kreisen relativ
        unbekannt, obschon sie erhebliche Vorteile gegenüber der Bash hat und gegenüber der
        Tcsh auch eine ziemlich große Ähnlichkeit mit der Ksh und der Bourne-Shell aufweist und
        sich auch fuer Skripte ausgesprochen gut eignet.</p>
        
        <h2><a name="faehigkeiten"></a>Fähigkeiten, die an der Zsh faszinieren</h2>
        
        <ol>
        
          <li>Man braucht kaum umzulernen: Die meisten Kommandos sind so, wie man sie von der
          Bash und der <em>Ksh</em>, die sie vor allem nachahmt, kennt. Oft kann man auch
          durch eine Beschreibung der <strong>Ksh</strong> eine Menge lernen.  Diese ist
          nämlich in vielen älteren Unix-Büchern ausführlich beschrieben.</li>
          
          <li>Für Umsteiger bietet die Zsh einen Emulationsmodus für Sh, Csh und Ksh an.
          Beispielsweise versucht <code>emulate sh</code>, die SH zu emulieren.
          (siehe auch <code>man zshbuiltins</code> unter emulate.)</li>
          
          <li>Außerdem zwingt die Shell dem Anwender nie ein bestimmtes Verhalten auf.  Mit
          über 150 Optionen lässt sich ihr Verhalten sehr flexibel an den Geschmack und die
          Bedürfnisse des Benutzers anpassen.<br> So kann man mit der Z-Shell falsche Eingaben
          korrigieren lassen, ist aber dazu in keiner Weise gezwungen: (<code>unsetopt
          correct</code>) und die Vervollständigungen sind bis ins allerkleinste Detail
          anpassbar.</li>

          <li>Die Zsh ist ausgesprochen modular (über 25 Module). Damit ist der Nutzer in der
          Lage, ganz nach Bedarf bestimmte Features zu benutzen und andere völlig auszusparen.
          <br>

          So hat die Zsh z.B. ein Mathematik-Modul mit über 30 mathematischen Funktionen, die
          viele nicht brauchen werden, für manche aber sehr nützlich sind. Gleiches gilt für
          das Profiler-Modul (zprof), ein mit den internen Vervollständigungen arbeitendes
          FTP-Modul (zftp), das Pseudoterminal-Modul zur Automatisierung von Programmen, die
          ein Terminal erwarten (zpty), u.s.w...</li> 

          <li>Die Zsh kann Funktionen mit <code>zcompile</code> in eine für den Computer
          schneller zu lesende binäre Ausführungsform bringen. Dabei wird ein Word-Code ähnlich
          dem Java-Bytecode erzeugt, nur, dass dabei words (2 Bytes) benutzt werden. So kann
          man die Funktionen erheblich beschleunigen.</li>
 
          <li>Intuitiv (wie in Perl, Python, Ruby) lassen sich in Zeichenketten Ersetzungen
          durch Zeichenketten-Indizes machen:

<pre class="rahmen">
a="ich hab nix gemacht.";a[1]='I';a[-1]='. (Bart Simpson)'</pre>

          </li>

          <li>Die Zsh unterstützt assoziative Arrays (Variablen-Felder mit <em>Buchstaben als
          Index</em>):
          
<pre class="rahmen">
typeset <em>-A</em> ass_array; ass_array=(eins 1 zwei 2 drei 3 vier 4)</pre>

          deklariert und definiert eine auch Hash genannte Feldvariable, deren einzelne
          Elemente einen Index aus Buchstaben besitzen.

          <code>print $ass_array[eins]</code> gibt im Beispiel das erste Element, 1,  aus,
          <code>print ${<em>(k)</em>ass_array}</code> gibt die Keys (Schlüssel),
          <code>print ${<em>(v)</em>ass_array}</code> die Values (Werte).
          </li>
        
          <li>Temporäre unbenannte Variablen ermöglichen es, Teile aus Zeichenketten zu
          extrahieren und alle möglichen Umwandlungen durchzuführen:
          
<pre class="rahmen">
print ${<font color="green">$(</font> date <font color="green">)</font>[1]}</pre>
          
          gibt das erste Wort, was date liefert, aus.  Dazu muss der Befehl <code>date</code>
          in <code>$()</code> angegeben werden (die alte Bourne-Shell-Schreibweise innerhalb
          von <code>``</code> funktioniert hier nicht!).<br>

          <code>$(date)</code> wird umschlossen von <code>${[1]}</code>, was das erste Wort
          hervorbringt. Diese Konstruktion kann man beliebig verschachteln, was nur den
          Nachteil besitzt, mit größerer Verschachtelungstiefe sehr unleserlich zu werden.
          <br>
          
<pre class="rahmen">
print <font color="red">${</font><font color="green">${</font><font color="blue">$(</font> LC_ALL=de_DE /sbin/ifconfig ppp0 <font color="blue">)</font>[5]<font color="green">}</font>#Adresse:<font color="red">}</font></pre>


        könnte bei Verwendung von pppd unter Linux die IP-Adresse ausgeben, wobei nebem dem
        eben gezeigten Mechanismus zusätzlich die Zeichenkette "Adresse:" gelöscht wird.<br>
        
        Es ist auch möglich, head, tail, uniq, sort und sogar grep durch interne Mechanismen zu
        ersetzen. Dazu muss so vorgegangen werden, dass der Modifier <code>(f)</code> im
        <em>Index</em> der unbenannten Variablen Verwendung findet.  Dies führt dann dazu, dass
        bestimmte Zeilen statt Buchstaben durch den Index ausgewählt werden:

<pre class="rahmen">
print -l ${&quot;$( &lt; datei )&quot;[<font color="red">(f)</font>5]}</pre>

        gibt die Zeile 5 aus "datei" aus.<br>
        
<pre class="rahmen">
print ${&quot;$( &lt; /etc/passwd )&quot;[(<font color="red">f</font><font color="blue">r</font>)*root*]}</pre>

        gibt die erste Zeile, in der "root" vorkommt aus, wobei in diesem Fall im Index nach
        einem Muster (hier: "*root*") mittels <code>(r)</code> gesucht wird.</li>

        <li> Als regelrechtes grep mit allen Vorkommen kann man folgenden Mechanismus benutzen:

<pre class="rahmen">
print -l ${(<em>M</em>)${<font color="green">(f)</font><font color="red">&quot;</font>$(&lt; /etc/passwd)<font color="red">&quot;</font>##*$muster*}} (f) </pre>
        
        liest die in Anführungsstrichen stehende Ausgabe der Datei zeilenweise in eine
        unbenannte Variable.  Wie auch in anderen Shells schneidet <code>##</code> am Anfang
        <code>*$muster*</code> ab.<br>
        
        Da aber <code><em>(M)</em></code> benutzt wird, werden alle Zeilen, bei denen das
        Muster zutrifft, nicht abgeschnitten, sondern alleine ausgegeben. Das Gegenstück dazu
        ist <em>(R)</em>, was im vorigen Fall dann einem "grep -v" entspricht.<br>
        
        Würde man nur ein <code>#</code> angeben, würden die Sterne (Stellvertreter für 0 oder
        mehr Zeichen) geizig - mit so wenig Zeichen wie möglich - ausgegeben. In diesem Fall
        würde dann also nur <code>$muster</code> selber ausgeben.</li>

        <li> Zsh kann wie bekanntere Programmiersprachen (Perl, Python, Ruby z.B) im Index
        einer Variablen ein "von_feld,bis_feld".

<pre class="rahmen">
print ${$( date )<em>[2<font color="magenta">,</font>4]</em>}</pre>

        gibt vom zweiten bis vierten Wort das von "date" gelieferte Ergebnis aus.  Oder es geht
        auch mit negativen Index:
        
<pre class="rahmen">
print ${${:-eins zwei drei vier fuenf}<em>[2,-2]</em>}</pre>

        gibt als Ergebnis <code>zwei drei vier</code> aus. ('<code>:-</code>' ersetzt den
        fehlenden Variablennamen hier wie bei der Bash durch seine Werte).<br>
        
        Bei Arrays ist es auch möglich, zweidimensionale Indizes zu gebrauchen:<br>
        
<pre class="rahmen">
print ${$(date)[4][1,5]}</pre>

        gibt die Uhrzeit von date ohne Sekunden aus.</li>

        <li> Mit Hilfe des Moduls <code>pcre</code> kann die Zsh seit Version 4.1.1 Perls
        reguläre Ausdrücke verarbeiten. Dazu lädt man mit <code>zmodload zsh/pcre</code> das
        PCRE-Modul ein, kompiliert dann einen beliebigen perlartigen regulären Ausdruck mit
        Hilfe von <code>pcre_compile</code> und verarbeitet anhand des Fehlercodes 1 bzw. 0
        alles weitere. Beispiel:
        
<pre class="rahmen">
<em>pcre_compile</em> '\s\d\.\d{3}\.\d{3} Euro' &&\
<em>pcre_match</em> ' 1.000.000 Euro'\
&& echo "Trifft zu!" || echo "Trifft nicht zu!"</pre>

        Bei komplexeren Ausdrücken kann man die Geschwindigkeit noch durch <em>pcre_study</em>
        verbessern.</li>

        <li>Mit dem sogenannten Here-String kann man eine Art Here-Document benutzen ohne ein
        EOT-Signal auf einer Extra-Zeile eingeben zu müssen:

<pre class="rahmen">
for Programm in cat tail head grep ; do &gt;&gt; /tmp/datei  \
<em>&lt;&lt;&lt;</em> "Hallo,Welt! Ich habe das Geüfhl, mein             \
externes $Programm wird bald nicht mehr so viel benutzt." ; done</pre>

        Man achte auch auf das Auslassen von cat, was bei der zsh nicht mehr nötig ist!</li>

        <li>Fließkommazahlen können berechnet werden:

<pre class="rahmen">
printf "%.0f\n" $[ <em>2.8</em>*15 ]</pre>

        Ausserdem kann in verschiedenen Zahlensystemen gerechnet werden, in dem in eckigen
        Klammern <code>[#&lt;zahlensystem&gt;]</code> geschrieben wird, also:
        
<pre class="rahmen">
for (( i=1; i<100; i++ )) { print $(( <em>[#10]</em> i)) }</pre>

        entspricht

<pre class="rahmen">
$(( <em>[#16]</em> i )) }</pre>

        Bei zweifacher Angabe von <code>#</code> wird das Zahlensystem nicht ausgegeben.<br>
        
        Sogar einen "Taschenrechner" gibt es in der Zsh, der nach <code>autoload
        <em>zcalc</em></code> zur Verfügung steht.</li>

        <li> Die Zsh kann alles vervollständigen, was man sich so ungefähr vorstellen kann.
        (siehe auch <code>zshcompctl</code> und seit 3.1.6 <code>zshcompsys</code> .
        
        <!-- Sie erweitert sogar noch erheblich die Möglichkeiten, die die in
        dieser Hinsicht vorbildliche Tcsh bietet. -->

        (Programmierbare Vervollständigung ist für die Bash erst seit April 2000 (Version 2.04)
        und bei der Ksh gar nicht vorhanden. Seit Zsh 4.1 können sogar die
        Vervollständigungsmechanismen der Bash genutzt werden unter Verwendung von
        <em>bashcompinit</em>.)<br>
        
        Mit der Version 3.1.6 wird eine neue Richtung in der Programmierung von
        Vervollständigungen vorgelegt.<br>
        
        Statt mit Optionen lässt sich der Ergäzungsmechanismus der Shell nun sehr viel
        einfacher durch den Aufruf von über 400 vordefinierten Funktionen programmieren.<br>

        Das hat den Vorteil: Für sehr viele Bereiche lässt sich durch Kopieren und Editieren
        schnell eine neue Vervollständigung fertigstellen, da man jetzt nicht mehr so
        detailiert wissen muss, wie die neuen Vervollständigungen zu programmieren sind.
        Außerdem muss man häufig sogar einfach nur mit <code>autoload compinit &amp;&amp;
        compinit</code> den neuen Mechanismus blind in Gang setzen und kann direkt
        vorgefertigte Vervollständigungs-Mechanismen nutzen.  Man rufe danach beispielsweise
        einmal <code>xterm -fn «TAB»</code>auf. (Siehe auch <a
        href="compsys.html">hier</a>)<br>

        Beispiele zur Vervollständigung (noch nach dem alten Schema bis
        3.1.5):

<pre class="rahmen">
compctl -g '*(/)' cd </pre>

        macht aus einer einfachen Dateiergänzung  wie der Ksh eine intelligente
        Vervollständigung für "cd", die nur noch Verzeichnisnamen aufführt.<br>
        
        Vor allem mit <code>compctl -k '(`aktion`)'</code> lassen sich
        sehr praktische Vervollständigungsmechanismen erstellen.
        Man kann sich so z.B. ohne Probleme bei Aufruf eines Email-Programmes nur
        Email-Adressen und mit ftp nur FTP-Adressen  vervollständigen lassen.
        Außerdem kann man bei der Vervollständigung auch Dateienden
        abschneiden lassen.
        Das ist z.B. bei Java sehr praktisch.
        
<pre class="rahmen">
compctl -g '*.class(:r)' java</pre>

        (Mehr Beispiele <a href="compctl.html">zur älteren Vervollständigung hier</a>)</li>

        <li>
        Mit der Zsh kann man sehr gezielt nach Worten in Dateien suchen:
        Nach dem Freischalten von Sonderzeichen für die Reichweite eines
        glob-Befehls mit <code>setopt extended_glob</code> ist folgendes machbar:

<pre class="rahmen">
grep Wort *<em>~(</em>*.gz|*.bz|*.bz2|*.zip|*.Z<em>)</em></pre>

        sucht 'Wort' nicht mehr in den komprimierten Dateien im Mail-Ordner.<br> <code>~</code>
        bedeutet hier so viel wie "außer".<br>

        Alle Dateien, die nicht die Endung *.bz2 und auch nicht *.gz enthalten , sucht man mit

<pre class="rahmen">
ls <em>^(</em>*.bz2|*.gz<em>)</em></pre>

        Das <code>^</code> ist also das "NICHT", das Ausrufezeichen wird von der Zsh für alte
        Befehle benutzt.<br>

        An dieser Stelle bietet sich vielleicht ein globales Alias für komprimierte Dateien an
        (siehe weiter unten).  <br>

        Zusätzlich zu <code>^</code> und <code>~</code> lassen sich die Ausdrücke
        <code>#</code> und <code>##</code>benutzen, um null und mehr bzw. ein und mehr
        Vorkommen des Zeichens davor zu erhalten, was bei Perls regulären Ausdrücken den
        Zeichen <code>*</code> bzw.  <code>+</code> entspricht.</li>

        <li> Globale Aliase sind Aliase, die nicht nur am Anfang der Kommandozeile oder nach
        <code> ; </code> als Aliase wirken können.  Sie sollten gut gekennzeichnet werden:

<pre class="rahmen">
alias <em>-g</em> §k="*~(*.bz2|*.gz|*.tgz|*.zip|*.z)"</pre>

        und danach der Befehl

<pre class="rahmen">
ls -d §nk </pre>

        listet alle nicht-komprimierte Dateien auf.<br>

        Mit <code> unalias <em>'</em>§k<em>'</em> </code> wird man dieses globale Alias wieder
        los. Wichtig hierbei sind die einfachen Anführungsstriche. Sonst wirkt nämlich §k
        weiter, was nicht im Sinne des Benutzers wäre.</li>

        <li>Aliase können seit Version  4.2 auch verwendet werden, um bestimmten
        Zeichenketten-Endungen (Suffixes) <em>nach</em> einem Punkt automatisch mit dem selben
        Befehl aufzurufen, was meist für Dateiendungen benutzt wird. Dabei gilt:<br>
        
<pre class="rahmen">
alias -s <font color="ed">NAME</font>=<font color="green">WERT</font></pre>

        wobei TEXT.<font color="red">NAME</font> dann durch die Zsh zu <font
        color="green">WERT</font> TEXT.<font color="ReD">NAME</font> wird.

<pre class="rahmen">
alias <em>-s</em> <font color="red">txt</font>=<font color="green">'less -rE'</font></pre>

        ruft alle <em>ohne Befehl</em> aufgerufenen .txt-Dateien automatisch mit dem Befehl
        <code>less -rE</code> auf, so dass man jetzt einfach nur den Dateinamen und ein return
        eingeben muss. Diese Funktionalität ist vergleichbar mit dem Anklicken einer oder
        mehrerer Dateien mit einem graphischen Dateimanager. Dabei kann man auch globale
        Zeichen wie <code>*</code> verwenden, also beispielsweise <code>*.txt</code> und ein
        "enter" eingeben um alle Dateien mit Endung ".txt" mit less zu lesen.

        <br>Praktischerweise gibt es mit <code>autoload zsh-mime-setup ; zsh-mime-setup</code>
        die Möglichkeit, anhand der Mime-Definitionen in /etc/ schon bestimmte Datei-Endungen
        mit bestimmten Programmen zu belegen.<br>

<pre class="rahmen">
alias -s <font color="red">de</font>=<font color="green">w3m</font>
alias -s <font color="red">at</font>=<font color="green">w3m</font></pre>

        ruft alle WWW-Seiten mit .de oder .at direkt mit w3m auf. ('.de' bzw. '.at' in der
        Eingabe ist in diesem Fall <em>keine</em> Dateiendung!) </li>
        
        <li> In der Zsh kann man aus jeder eigenen Funktion eine Datei machen, ohne dass diese
        Datei ausführbar sein muss.  Hierzu setzt man die Variable FPATH bzw fpath (siehe unten)
        auf das oder die Verzeichnisse, die berücksichtigt werden sollen.  <br>

        In der Datei genügt es, einfach eine oder mehrere Funktionen zu schreiben, z.B:

<pre class="rahmen">
begruessung() { echo "Hallo, $1" ; }
herzlich()    { echo "Ist ja riesig, $1, Dich zu sehen" ; }</pre>

        Jetzt muss noch dieser Dateiname mit <code><em>autoload</em> <em>dateiname</em> </code>
        bekannt gemacht werden.  Daraufhin stehen nach einmaligem Aufruf des  Namens der
        Funktionen die beiden Funktionen dann zur Verfügung.  Schreibt man nur den
        Funktionsrumpf allein dann hat das gegenüber dem Schreiben von Funktionen den Vorteil,
        sofort ausgeführt werden zu können. autoload-<em>Funktionen</em> müssen nämlich <!--
        normalerweise --> erst einmal aufgerufen werden, damit ihr Rumpf bekannt ist. Beispiel:

<pre class="rahmen">
echo "Ist das schön, $1, Dich zu sehen\!" &gt; ~/.zsh/funktionen/begruessung</pre>

        ist nach Aufruf von <code>autoload begruessung</code> sofort nutzbar.  (Siehe
        AUTOLOADING FUNCTIONS unter 'man zshmisc') </li>
        
        <li>
        Statt in eine "Backslashitis" beim Aufschreiben von Skalar-Variablen mit viel
        Inhalt zu verfallen (z.B. beim Definieren des Pfades) gibt es bei der Zsh die
        Möglichkeit,
        das kleinbuchstabige Gegenüber des großbuchstabigen
        Variablennamens als eines Arrays zu verwenden und sogar für eigene
        Variablen mit
        <code>typeset -T</code> ein "Gegenüber" von einer Skalar-Variable zu einer
        Feld-Variable durch die Kleinschreibweise der Variablen zu erzielen.
        <br>
        Dieser Variante kann man dann ein Feld aus Werten - durch Leerzeichen
        oder Zeilenumbruch getrennt - zuweisen. Beispiel PATH:

<pre class="rahmen">
alt: PATH=/usr/bin\
     :/usr/local/bin/\
     :/usr/sbin\
     :/usr/local/sbin\
     :/usr/X11R6/bin

zsh: <em>path=(</em> /usr/bin /usr/local/bin /usr/sbin /usr/local/sbin /usr/X11R6/bin <em>)</em></pre>

        Da die Zsh für Feldvariablen runde Klammern braucht (wenn nicht <code>setopt
        shwordsplit</code> gesetzt ist) sind die Worte in runde Klammern eingeschlossen.  <br>

        Wer allerdings kompatibel zur Sh/Ksh/Bash programmieren <b>muss</b>/<b>will</b>, der
        muss die Option <code>setopt shwordsplit</code> setzen.</li>
        
        <li><em>Zle</em> - der Zeileneditor der Zsh - ist den Zeileneditoren anderer Shells
        überlegen.  Hier kann man fröhlich mehrere Zeilen schreiben und nach dem Aufruf mit
        RETURN separat einzelne Zeilen korrigieren. Man muss also nicht mehr immer einen
        externen Editor aufrufen.<br>
        
        Besonders nett dabei: Wo die Bash nur das Manövrieren wie in einer einzigen Zeile
        zulässt, kann man bei der Zsh bequem mit dem Cursor - wie in einem Editor - über
        mehrere Zeilen navigieren.<br>

        Will man innerhalb mehrerer Zeilen editieren, dann muss man entweder mit <code>bindkey
        "^Xp" push-line-or-edit</code> oder ähnlicher Tastenbelegung diesen Puffer in einen
        anderen Puffer kopieren oder aber nach einem Control-C erneut die Zeilen zurückholen.
        </li>
        
        <li>
        Mittels <em>zle -N</em> kann man eigene, sogenannte Widgets (das sind
        Editier-Funktionen) zle bekannt machen.  In den Variablen <em>LBUFFER</em> und
        <em>RBUFFER</em> liegt die Kommandozeile links bzw. rechts des Cursors, die man
        so sehr einfach manipulieren kann. Beispiel:

<pre class="rahmen">
klammer() { LBUFFER="\${$LBUFFER" ; RBUFFER="}$RBUFFER" }</pre>

        erzeugt
        eine Funktion klammer, die man mit <code>bindkey '^g' klammer</code> jetzt
        an die Taste Control-G zuweisen kann.<br>
        
        Noch ein Beispiel für ein User-Widget:
<pre class="rahmen">
wohin() {
  dirs -v
  print -n "Wohin? "
  read WOHIN
  cd +${WOHIN:=0}
}</pre>

        Jetzt muss mit '<code>zle -N </code>' "wohin" als User-Widget deklariert werden.
        Anschließend kann mit '<code>bindkey '^Ww' wohin</code>' die definierte und deklarierte
        Editier-Funktion auf '<code>Control-Ww</code>' gelegt werden.<br>
        
        Zusätzlich kann man mit '<code>autoload <em>zed</em></code>' sogar einen Editor (der in
        der Z Shell selber geschrieben ist) benutzen, der dann von seiner Voreinstellung oder
        durch '<code>bindkey -e</code>' Emacs-artig, bei Eingabe von '<code>bindkey -v</code>'
        vi-artig funktioniert. Gesichert wird allerdings durch '<code>control-x control-w</code>'
        oder im Vicmd-Modus mit '<code>ZZ</code>' und mit dem Befehl control-c bricht man ab.
        Ruft man zed mit der Option -f oder als <em>fned</em> auf, kann man Funktionen
        editieren.<br>
        
        Als wohltuend empfinden wir bei einem Kommando des Zeileneditors das Kommando
        <em>insert-last-word</em>, das im Gegensatz zur Bash nicht immer das letzte Wort,
        sondern bei wiederholtem Aufruf das letzte Wort davor und so weiter aufruft. (Siehe
        auch '<code>man zshzle</code>') </li>
        
        <li>Die Zsh unterstützt wie ihr Vorbild -die Ksh- Koprozesse.  Koprozesse sind eine
        Möglichkeit, an Parallelprozesse Daten zu übergeben und Daten zu empfangen.  Diese
        Koprozesse werden allerdings mit '<em>coproc</em>' eingeleitet und nicht wie bei der Ksh
        mit <code> |&amp; </code>.<br> Mit '<em><code> print -p</code></em>' und mit
        '<em><code>&gt;&amp;p </code></em>' als Umlenkung kann ich Daten an den Prozeß senden und mit
        '<em>read -p</em> und '<em><code>&lt;&amp;p</code></em>' als Umlenkung Daten von diesem Prozeß
        auslesen. Beispiel:

<pre class="rahmen">
<em>coproc</em> ed /tmp/notizen
<em>print -p</em> "a"
ls -l <em>&gt;&amp;p</em>
<em>print -p</em> ".\nwq"</pre>

        schreibt in einen parallel laufenden Koprozess, den altehrwürdigen Ed, die Ausgabe von
        '<code>ls -l</code>' und speichert den Inhalt in der Datei /tmp/notizen ab und beendet
        ed.  <br>
        
        Weitgehender als ein Coprozess ist das Laden des <em>zpty</em>-Moduls mit
        '<code>zmodload zsh/zpty</code>', welches dann ähnliche Steuerungsmöglichkeiten wie das
        Programm expect bietet. Als Beispiel für die Verwendung von zpty kann das Skript
        nslookup in /usr/share/zsh/4.x.x/functions/ dienen, was das gleichnamige interaktive
        Programm durch seine Vervollständigung leichter bedienbar macht.  </li>
        
        <li>Die Zsh kennt die Formatierungen, die die Ksh kennt.  <em>typeset</em> - oben schon
        kurz bei assoziativen Variabelfeldern erwähnt - ist ein mächtiger Formatierbefehl der
        Ksh.  Mit diesen Formatierungsregeln lassen sich Ausgaben auf unterschiedliche Weise
        formatieren.

<pre class="rahmen">
<em>typeset -L2</em> name=werteintrag ;print "[$name]"</pre>

        gibt linksformatiert "[we]" aus, die ersten 2 Buchstaben, umrahmt von [].

<pre class="rahmen">
<em>typeset -lL20</em> name=WERT;print "[$name]"</pre>

        gibt in Kleinbuchstaben (-l für lower)
        "[wert&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;]" aus, wobei 20 - 11
        Leerzeichen eingefügt werden.

<pre class="rahmen">
<em>typeset -r</em> RPROMPT=%n</pre>

        schützt den Rechtsprompt vor einem versehentlichen Überschreiben. Die Variable ist
        jetzt read-only und zsh warnt einen mit "zsh: read-only variable: RPROMPT ".  Alle
        typeset-Befehle können mit  einem <code>-</code> statt dem <code>+</code> aufgehoben
        werden. (Siehe <code> man zshbuiltins </code> unter typeset)<br>

        Zusätzlich zu <code>typeset</code> kann man auch durch sogenannte Modifier die Ausgabe
        von <code>print</code> verändern.  Beispiel:

<pre class="rahmen">
name="Wert"
print "[${(Ll:20:)name}]"</pre>

        ergibt genau die selbe Ausgabe wie
<pre class="rahmen">
typeset -lL20 name</pre>

        Seit Zsh 4.1.1 kann man mit

<pre class="rahmen">
printf "%20s\n" ${(L)a}</pre>

        ähnlich wie in der gleichnamigen C-Funktion auch dieses Ergebnis bekommen, ohne den
        externen printf-Befehl nutzen zu müssen.</li>
        
        <li>Die Ausgabe von Dateinamen kann mittels sogenannter Qualifier spezifiziert werden
        (siehe <code> man zshexpn </code> unter Glob Qualifier). Beispiele:

<pre class="rahmen">
print -l *<em>(m-1)</em> # listet nur Dateien zeilenweise auf, die vor
                # bis zu einem Tag modifiziert wurden

print -l *<em>(a1)</em>  # listet Dateien zeilenweise auf, auf die vor einem
                # Tag zugegriffen wurde
 
print -l *<em>(@)</em>   # listet nur die Links zeilenweise auf

ls -doF *<em>(/)</em>    # findet nur die Verzeichnisse

chmod 640 *<em>(W)</em>  # verändert die Rechte aller Dateien, in die
                # jeder schreiben darf, denn das ist ja meistens
                # besonders riskant!
 

grep name *<em>(.)</em>  # findet nur noch reine Dateien. Damit ist
                # die unsinnige Meldung "grep: bla: Is a directory"
                # für alle Zeiten vermeidbar.
</pre>

        Um einmal wieder an alte schlechtere Zeiten erinnert zu werden, könnte man auch
        '<code>grep name *<em>(^.@)</em></code>' eingeben. Hiermit werden alle Dateien
        aufgelistet, mit denen grep nichts anfangen kann, denn '^' ist das Nicht-Zeichen
        :).<br>

<pre class="rahmen">
gg() { grep -wE "$1" *<em>(.)</em> | less -r }</pre>

        könnte eine kleine Zsh-Funktion sein, um gezielt nach einem Wort und unter Zuhilfenahme
        von regulären Ausdrücken zu suchen.  Ich persönlich (Matthias) benutze allerdings
        lieber Perl für solche Dinge und habe dafür das Perl-Programm <code>mg</code> entdeckt.
        </li>
        
        <li>Ein sehr schneller Befehl, um DOS-Dateien (keine Verzeichnise) zu Dateien mit
        kleinen Buchstaben zu machen ist:

<pre class="rahmen">
for i in [A-Z][A-Z]*<em>(.)</em>; do mv $i ${i<em>:l</em>} ;done</pre>

        Der Qualifier <em>:l</em> (für lowercase) leistet hier ganze Arbeit.

<pre class="rahmen">
print -l *<em>(LM+3)</em></pre>

        gibt zeilenweise Dateien aus, die über 3 Megabyte groß sind.</li>
        
        <li> Ich kann unter der Zsh komprimierte Email-Pakete lesen, ohne mich zuerst um das
        Entpacken kümmern zu müssen. Das geht bei gzip-gepackten Dateien z.B. so:

<pre class="rahmen">
 mutt -f <em>=(</em>zcat mailfold*.gz<em>)</em></pre>

        In den <em>=()</em> steht dabei die Aktion, die mit einer Datei gemacht wird, es wird
        dabei eine temporäre Datei erzeugt und mit ihr z.B. mutt -f aufgerufen.  Ein anderes
        Beispiel: 

<pre class="rahmen">
mutt -f =(grepmail "Mustafa Mustermann" ~/mbox)</pre>

        sucht alle Emails von Mustafa Mustermann aus einer sehr großen Email-Datei namens mbox mittels
        <code>grepmail</code>, einem sehr mächtigen Perl-Programm zum Herausfiltern von Emails,
        welche einem bestimmten Kriterium entsprechen, heraus.  Die temporäre Datei wird
        selbstverständlich nachher wieder gelöscht.<br>
        
        <a href="tools_mutt.html">mutt</a> ist ein sehr schönes Mail-Programm, welches auch auf
        der Kommandozeile funktioniert, das wir sehr  empfehlen können.  Mit 'mutt -f' liest
        mutt nicht aus /var/spool/mail sondern die Email-Datei, hier mehrere Emaildateien. Ein
        anderes Beispiel:
     
<pre class="rahmen">
lynxbzgrep() {
  lynx -force_html -dump <em>=(</em>bzip2 -cd $1 | grep $2<em>)</em>
}</pre>

        ermöglicht es, mit lynxbz bzip2-gepackte HTML-Seiten nach einem Begriff zu untersuchen.
        Nötig wird dieser Mechanismus, wenn ein Programm <code>lseek</code> benötigt. (Siehe
        <code>man 3 lseek</code>)<br>

        Wird keine temporäre Datei benötigt, dann kann man wie auch bei der Bash
        '<em><code>&lt;()</code></em>' verwenden. Damit erspart man sich dann die manuelle
        Verwendung von <code>/proc/self/fd</code> oder die manuelle Erzeugung einer "named
        pipe":
        
<pre class="rahmen">
lynx -force_html &lt;( gzip -cd komprimiert.html.gz )</pre>

        ist ein Beispiel, bei dem lynx die Ausgabe von '<code>gzip -cd
        komprimiert.html.gz</code>' verarbeitet.  <br>

        Durch intelligente Kommunikation verschiedener Prozesse wird es möglich, dass man zwei
        Pseudodateien erzeugen und miteinander vergleichen kann: In Shellkreisen wird dies als
        'named pipe' bezeichnet, die die Zsh indirekt erzeugt.

<pre class="rahmen">
diff &lt;(zcat erste_datei.gz) &lt;(zcat zweite_datei.gz)</pre>

        vergleicht den Inhalt von zwei komprimierten Dateien miteinander.</li>
        
        <li>Nach Setzung von READNULLCMD=less lässt sich eine Datei mit:

<pre class="rahmen">
&lt; datei</pre>

        unter less angucken. Einfach ein <code>&lt;</code> vor die Datei setzen.</li>
        
        <li>Es ist ohne Probleme möglich, die Standardausggabe an mehrere Dateien umzulenken:

<pre class="rahmen">
ls &gt;datei1 &gt;datei2 &gt;datei3</pre>

        oder:

<pre class="rahmen">
ls &gt;&gt; datei1 &gt;&gt; datei2</pre>

        </li>
        
        <li> Man kann auch die Standardeingabe von mehreren Dateien empfangen:

<pre class="rahmen">
less &lt; datei1 &lt; datei2</pre>
        </li>
        
        <li> Es ist möglich, eine Umlenkung in eine Datei und gleichzeitig an eine Pipe zu
        bewerkstelligen:

<pre class="rahmen">
make &gt;logfile | grep Error</pre>
        </li>
        
        <li> Mit <code>ls -lL <em>=</em>emacs</code> kann man beispielsweise in jedem
        Verzeichnis schauen, wie groß 'emacs' genau ist. Man muss nicht mehr den Pfad angeben.
        Die Zsh schaut dabei selbst im Pfad nach, wenn man emacs im Pfad hat. Man kann auch
        bequem Dateien, die im Pfad stehen, auf diese Art editieren.

<pre class="rahmen">
jed <em>=</em>genial.c</pre>

        editiert eine C-Funktion, wenn sie im Pfad gefunden werden kann.</li>
        
        <li> Statt eines sehr expliziten aber umständlich zu tippenden find-Befehls kann under
        der Zsh <em>**</em> als rekursives Kürzel verwendet werden. Mit:

<pre class="rahmen">
print -l <em>**</em>/*.html</pre>

        findet man alle HTML-Seiten, die
        in allen Verzeichnissen unterhalb des jetzigen Verzeichnisses vorhanden
        sind und gibt sie auf je einer Zeile (-l) aus.(**=Rekursion)<br>
        
<pre class="rahmen">
print -l **/datei.html # sucht die bestimmte Datei in allen
                       # vom aktuellen Verzeichnis abgehenden
                       # Verzeichnissen und gibt genau sie aus.

print -l **/*.html~datei.html # gibt alle HTML-Seiten
                              # mit Ausnahme von datei.html zeilenweise aus.

grep name **/*.txt  # sucht in allen Texten unterhalb des
                    # gegenwärtigen Verzeichnisses nach Dateien
                    # mit Endung .txt.
</pre>

        </li>
        
        <li>Mit <code><em>vared</em></code> kann man alle Umgebungsvariablen editieren. Das
        finden wir praktisch, weil wir sofort die Variable erreichen und nicht erst in einer
        Datei wie .zshrc nach ihr suchen müssen.  Außerdem wirkt das Editieren der Variablen
        natürlich sofort.</li>
        
        <li>Der Befehl <code>dirs <em>-v</em></code> zeigt alle Verzeichnisse, in denen man in
        einer Sitzung gewesen ist zeilenweise an. Wenn man <br> <code>setopt autopushd</code>
        setzt, kann man nun mit cd +2 das vorletzte Verzeichnis erreichen.</li>
        
        <li> Mit der Zsh kann man sehr lange Unterverzeichnisse im Prompt mit einem kurzem oder
        signifikanteren Namen (named directory) versehen und dann mit ~name aufrufen.  Das ist
        insbesondere dann sehr praktisch, wenn man in einem sehr entfernten Ordner von '/' aus
        gesehen arbeitet. <br>Ich (Matthias) habe mir eine kleine Zsh-Funktion geschrieben, die
        mir aus einem langem Verzeichnisnamen einen kurzen erzeugt: <br>

<pre class="rahmen">
zza () {
  NAMED_DIRECTORY=$PWD:t; # der Name des jetzigen Verzeichnisses wird
                          # an NAMED_DIRECTORY ohne die Hierarchie übergeben.
                          # :t steht für tail.
  eval $NAMED_DIRECTORY=$PWD; # es findet die Setzung eines named directory statt.
  cd ~$NAMED_DIRECTORY;       # es wird in das named directory gesprungen.
                              # ist mit dem bestehenden Verzeichnis identisch
                              # aber der Name ist kürzer im Prompt.
}
</pre>


        Eine außerdem sehr praktische Möglichkeit besteht darin, dass man jetzt nicht mehr den
        ganzen Pfadnamen angeben muss, wenn man eine Datei verschiebt. Z.B.:

<pre class="rahmen">
mv datei.1 ~lm1</pre>

        könnte die Datei bequem nach /usr/local/man/man1/ verschieben, wenn man
        <code>lm1=/usr/local/man/man1</code> gesetzt hat.<br>

        Bei der Prompt-Darstellung gibt es zwei Möglichkeiten: Entweder weisst man am Ende auch
        noch den letzten Slash zu: <code>info=/usr/local/info/</code> Dann wird im Prompt der
        ganze Name dargestellt.  <code>cd ~info</code> springt zwar nach /usr/local/info, aber
        im Prompt steht:

<pre class="rahmen">
/usr/local/info%</pre>

        Möchte man aber den kurzen Prompt haben, dann muss man so zuweisen:

<pre class="rahmen">
<em>info=</em>/usr/local/info</pre>

        -also ohne Slash am Ende.</li>
        
        <li>Die Option <code><em>autocd</em></code> erlaubt es, nur den Namen eines Ordners
        anzugeben.  Bei Eindeutigkeit wird dann sofort in diesen Ordner gesprungen.  Z.B.
        springt <code>bin «enter» </code> dann sofort in das bin-Verzeichnis.</li>
        
        <li>Es gibt keinen Fehler bei Farbprompts wie unter der Bash1-Shell. Gerade bei der
        Gliederung des Prompts ist das besonders wichtig. Da die üblichen Escape-Sequenzen sehr
        unleserlich sind gibt es in der Zsh eine besonders elegante Möglichkeit, um Farben zu
        definieren. Ein Beispiel:

<pre class="rahmen">
autoload -U colors &amp;&amp; colors
echo "$fg_bold[red]zsh $fg_no_bold[white]is $bg[blue]$fg_bold[green]nice"</pre>

        </li>
<!--
        Bei der Zsh müssen hierzu allerdings die Escape-Befehle von <code><em>%{</em>
        <em>%}</em> </code>eingerahmt werden.  Also zum Beispiel:

<pre class="rahmen">
<em>%{</em>^[[31m<em>%}</em>%~ <em>%{</em>[0m<em>%}</em></pre>

        Ich habe mir, um die Übersicht nicht zu verlieren, Variablen
        definiert, die die Farben für den Prompt enthalten.

<pre class="rahmen">
RED_PROMPT='<em>%{</em>^[[31m<em>%}</em>'
OFF_PROMPT='<em>%{</em>[0m<em>%}</em>'
</pre>

        Jetzt kann ich auf diese Variablen mit $ zugreifen.</li>
-->

        <li>Mit <em>RPROMPT</em> lässt sich ein PROMPT auf der rechten Seite
        definieren:<br>
        
        <code>RPROMPT=%l</code> zeigt beispielsweise an, auf welchem Rechner
        man sich befindet.<br>
        
        <code>RPROMPT=%n</code> zeigt den Benutzer an.<br>
        <code>RPROMPT=%T</code> zeigt die Zeit an.<br>
        <code>RPROMPT=%D{%d.%m.%y}</code>
        
        zeigt das Datum nach deutscher Darstellung an.</li>
        
        <li>Selbstverständlich kennt die Zsh auch eine Korrekturmöglichkeit bei
        falscher Eingabe, die aber nur dann wirksam wird, wenn man das wirklich
        eingestellt hat. Man setzt in einen solchem Fall einfach:

<pre class="rahmen">
setopt <em>autocorrect</em></pre>

        Die Korrektur kann durch Setzung eines

<pre class="rahmen">
alias &lt;befehl&gt;=<em>nocorrect</em> &lt;befehl&gt;</pre>
        
        verhindert werden.</li>
        
        <li>Um darüber informatiert zu werden, wer alles außer mir sich
        eingeloggt hat, gibt es das Kommando <code><em>watch</em></code> wie unter der
        Tcsh.<br>

<pre class="rahmen">
<em>watch=(</em>notme<em>)</em></pre>

        listet z.B. alle Benutzer auf, die nicht ich sind :)<br>

        Hierbei kann das Format der Ausgabe geändert werde:<br>

<pre class="rahmen">
<em>WATCHFMT</em>='%n eingeloggt auf Terminal %l von %M seit %T '</pre>

        Wählt man <code>watch=(@vorsicht_ist_angesagt)</code>, so werden alle Benutzer
        aufgeführt, die von dem Server vorsicht_ist_angesagt eingeloggt sind.<br> Positiv herum
        kann man so natürlich auch alle Freunde erkennen lassen:

<pre class="rahmen">
watch=( < ~/.freunde root)</pre>

        liest alle Freunde aus der Datei <code>.friends</code> in das Feld watch zusätzlich zu
        root ein. So kann man schnell erkennen, wenn sich Freunde einloggen.</li>
        
        <li>Es gibt in der Zsh einen sehr bequemen Wiederholungsbefehl, der von der tcsh
        abgeschaut ist: <code>repeat</code>.  Möchte man z.B. einen Werbemailer böswillig
        strafen, dann könnte man das so machen:<br>

<pre class="rahmen">
<em>repeat</em> 100 mail -s "spams suck" badcompany@devilsheart.com &lt; flame</pre>

        Dabei sollte allerdings bedacht werden, dass man damit meist harmlose Benutzer trifft,
        die schlechte Passworte haben und deshalb Räubern auf den Leim gegangen sind.</li>
        
        <li>Ruft man ein altes Kommando mit <code>!?kommando </code>auf, hat man die
        Möglichkeit, vor der erneuten Ausführung zu schauen, ob es sich hierbei auch um das
        gewünschte Kommando handelt. Man drückt dazu einfach «TAB».  Ebenso kann man sich auch
        die genau betroffenen Dateien eines global wirkenden Befehles (z.B. 'ls *.html') mit
        «TAB» ansehen.</li>
        
        <li>Gerade eben getippte Worte auf der Kommandozeile können mit
        !# genauer wiedergegeben werden als bei Bash/Tcsh/Ksh. Man gibt einfach
        an, wo wiederholt werden soll - z.B.:

<pre class="rahmen">
echo ein_langes_wort zweites_langes_wort drei !#1-2</pre>

        schreibt auf den Bildschirm: 'ein_langes_wort zweites_langes_wort drei ein_langes_wort
        zweites_langes_wort'.</li>
        
        <li>Um die Funktion funct alle 300 Sekunden auszuführen führt man einfach folgenden
        Befehl aus:

<pre class="rahmen">
periodic funct()  PERIOD=300 fortune -s</pre>

        Anmerkung: Allerdings muss dazu auch am Prompt ein Befehl eingegeben werden, sonst kann
        man natürlich nichts auf dem Bildschirm sehen.</li>
        
        <li>Die Zsh kennt den '..' Operator von Pascal (und Perl):

<pre class="rahmen">
echo {1..7} "\nWo ist denn die Bash geblieben?"</pre>

        ergibt:

<pre class="rahmen">
1 2 3 4 5 6 7
Wo ist denn die Bash geblieben?</pre>

        </li>
        
        <li>Die Zsh hat in ihrer sehr mächtigen HISTORY CONTROL ein <em>run-help</em>
        Kommando, mit dem zu einem Buffer gezielt Informationen abgerufen werden können.
        Voreingestellt ist hier der Aufruf der Manpage zu dem Kommando. Verändern könnte man
        diesen Aufruf, in dem man einfach aus:
        
<pre class="rahmen">
alias run-help=man # ein -&gt;
alias run-help=info</pre>

        macht.

<pre class="rahmen">
man_zshall() man zshall  # und nachfolgendes Deklarieren von
zle -N man_zshall        # kann durch Definition von
bindkey '^g' man_zshall  # nun immer bei Control-G ausgeführt werden.</pre>

        </li>
        
        <li><code>sched </code> ist ein interner Befehl zum automatischen, zeitgebundenen
        Abarbeiten von Kommandos ähnlich wie bei 'at'. Dabei werden die Kommandos
        aber nicht ausgeführt und dann als E-Mail zugeschickt, sondern gelangen
        erst einmal in den Puffer und werden beim nächsten Kommando erst
        auf dem Bildschirm ausgegeben.

<pre class="rahmen">
sched +0:10 figlet "Du musst jetzt los"</pre>

        führt in 10 Minuten in Großschrift auf dem Bildschirm eine Warnung zum Gehen aus.
        Dabei ist allerdings das Durchführen des Befehls abhängig von der Eingabe eines
        nächsten Befehls.</li>
        
        <li>Wer jetzt von der Z-Shell endgültig überzeugt ist und den Umstieg von z.B. der Bash
        wagt sollte sich die Bemerkungen von Matthias zum <a href="umstieg.txt">Umstieg von der
        Bash auf die Z-Shell</a> durchlesen.</li>

        </ol>

        <h2><a name="lokaledateien"></a>Lokale Dateien</h2>

        Folgende Dateien wurde von Matthias erstellt bzw. gesammelt:

        <ul>
          <li><a href="zsh.intro.ps.gz">Zsh Referenz-Karte als Postscript-Datei (gzip) [zsh.intro.ps.gz]</a>
          <li><a href="zsh-refcard.pdf">Zsh Referenz-Karte als PDF-Datei</a>
          <li><a href="compsys.html">compsys.html</a>
          <li><a href="compctl.html">compctl.html</a>
          <li><a href="umstieg.txt">umstieg.txt</a>
        </ul>

        Die <a href="tools_zsh.html">Zsh-Generell</a>-Webpage von Michael ist auch via <a
        href="#oben">obiger Navigation</a> erreichbar.

        <h2><a name="literatur"></a>Literatur</h2>
        
        <h3>Zsh-Homepage/Download</h3>

        <ul>
          <li><a href="http://www.zsh.org/">zsh.org</a>: zentrale Z-Shell-Homepage</li>
          <li><a href="http://zsh.sunsite.dk/">zsh.sunsite.dk/</a> - <em>Die</em> Zsh-Page schlechthin!</li>
          <li><a href="http://sourceforge.net/projects/zsh/">zsh.sf.net</a> - zsh-Projektseite
          bei sourceforge.net</li>
          <li><a href="http://bugs.debian.org/cgi-bin/pkgreport.cgi?pkg=zsh">Debian bug reports
          for zsh</a></li>
          <li><a
          href="http://arch.debian.org/cgi-bin/viewarch.cgi/schizo@debian.org--2004-zsh-upstream-cvs-head/zsh--cvshead--1.0">zsh-upstream-cvs-head
          @ debian</a></li>
          <li><a href="ftp://ftp.fu-berlin.de/pub/unix/shells/zsh/">ftp://ftp.fu-berlin.de/pub/unix/shells/zsh/</a> -
          Z-Shell Mirror Deutschland</li>
          <li><a href="http://www.zsh.org/mla/">Zsh - Mailing List Archive</a></li>
          <li><a href="http://zsh.sunsite.dk/links.html">Weitere Links auf der
          zsh-Homepage</a></li>
        </ul>
 
        <h3>Englische Artikel</h3>
        
        <ul>
          <li><a href="http://zsh.sunsite.dk/Guide/zshguide.html">A User's Guide to the Z-Shell</a> von Peter Stephenson (1999) </li>
          <li><a href="http://www-106.ibm.com/developerworks/linux/library/l-z.html?dwzone=linux">Introducing the Z-Shell</a> von IBM Developerworks (1.2.2001)</li>
          <li><a href="http://www.daemonnews.org/199910/zsh.html">Artikel in BSD-News</a> von Dominic Mitchell (Oktober 1999)</li>
          <li><a href="http://www.linux-mag.com/cgi-bin/printer.pl?issue=2002-05&amp;article=power">Making the Transition to Zsh</a> Artikel im englischsprachigen Linux-Magazin, von John Beppu (Mai 2002)</li>
          <li>Writing Zsh Completition Functions (Juli 2002): <a
          href="http://www.linux-mag.com/2002-07/power_01.html">Teil 1</a> und <a
          href="http://www.linux-mag.com/2002-07/power_02.html">Teil 2</a></li>
          <li><a href="http://www.acm.uiuc.edu/workshops/zsh/toc.html">Zsh Workshop</a> von
          Larry P. Schrof</li>
          <li><a href="http://strcat.neessen.net/zsh/">Zsh-Webpage</a> von Christian
          Schneider</li>
        </ul>
        
        <h3>Hilfreiches</h3>

        <ul>
          <li><a href="http://zsh.sunsite.dk/FAQ/">Z-Shell Frequently-Asked Questions</a></li>
          <li><a href="http://www.zshwiki.org/">Zsh Wiki und Sammelstätte von Tricks</a></li>
          <li><a href="http://www.zsh.org/mla/">Suche in der MailingList der Zsh</a></li>
           <li><a href="http://zsh.sunsite.dk/Refcard/refcard.ps.gz">Zsh Referenz-Karte als Postscript Datei (gzip)</a></li>
          <li><a href="http://www.int.gu.edu.au/courses/2010int/nscp_shells.html">http://www.int.gu.edu.au/courses/2010int/nscp_shells.html</a> - NCSP - Unix Shells; sehr guter englischer Text über Shells im Allgemeinen.</li>
          <li><a href="http://adamspiers.org/computing/shells/">Adam's UNIX shells page</a></li>
          <li><a href="http://www.opengroup.org/onlinepubs/007908799/xcu/shellix.html">The Single UNIX ® Specification, Version 2 - Shell Command Language Index</a></li>
          <li><a href="http://ftp.berlios.de/pub/netzworkk/scripts/Sources/">kwtools</a> - Eine
          sehr umfangreiche Zsh-Skriptsammlung (basierend auf <a
          href="http://packages.debian.org/unstable/misc/dialog">dialog</a>) von Kai Wilke für
          diverse oft gebrauchte Anwendungen</li>
          <li><a href="http://www.rayninfo.co.uk/tips/zshtips.html">Zzappers Best of ZSH
          Tips</a> - gesammelte Tipps von David Rayner</li>
          <li><a href="http://www.dotfiles.com/index.php3?app_id=4">zshrcs @ dotfiles.com</a></li>
        </ul>

        <h3>Live-CDs mit Zsh</h3>
        
        <ul>
          <li><a href="http://grml.org/">grml</a>
          <li><a href="http://kano.mipooh.net/kanotix/mirrors.html">Kanotix</a> 
          <li><a href="http://www.gobolinux.org">Gobolinux</a> (andere Dateisystem-Hierarchie)
          <li><a href="http://www.dynebolic.org">Dynebolic</a> (Fernsehen - und Radio-Sender werden)
          <li><a href="http://livecd.pld-linux.org">PLD-Linux</a> 
        </ul>

        <p>Diese Seite verlinken?<br />
        <a href="http://www.michael-prokop.at/computer/tools_zsh_liebhaber.html">
        http://www.michael-prokop.at/computer/tools_zsh_liebhaber.html</a>
        </p>

        <p>Bekennender Zsh-Liebhaber? Nutze einen dieser Button:<br />
        <a href="http://www.michael-prokop.at/computer/tools_zsh_liebhaber.html">
        <img src="http://www.michael-prokop.at/images/zsh_liebhaber.png" alt="zsh liebhaber
        webpage"></a>&nbsp;&nbsp;
        <a href="http://www.michael-prokop.at/computer/tools_zsh_liebhaber.html">
        <img src="http://www.michael-prokop.at/images/zsh_lover.png" alt="zsh lover"></a>

        <p>Die Autoren dieser Webpage (<a
        href="mailto:&#109&#97&#116&#116&#104&#105&#64&#105&#110&#102&#111&#100&#114&#111&#109&#46&#110&#111&#114&#116&#104&#46&#100&#101">Matthias
        Kopfermann</a> und <a href="/kontakt/">Michael Prokop</a>) sind via <a
        href="mailto:zsh-liebhaber@michael-prokop.at">zsh-liebhaber@michael-prokop.at</a>
        erreichbar! Feedback ist willkommen!</p>
        
        </div>
        
        <div class="up" id="Footer1">
          <a href="#oben"><img src="../images/nachoben.png" width="40" height="40" border="0" align="middle" alt="*"></a> 
          <a href="#oben">Nach oben</a>
        </div>
        <div id="Footer">
          <div class="online">
<!-->            <a href="http://www.michael-prokop.at/copyleft/">Copyleft</a> by Michael 
            Prokop und Matthias Kopfermann. <br>Diese Seite gehört zu <a
            href="http://www.michael-prokop.at/">www.michael-prokop.at</a>-->
            Autoren: Michael Prokop und Matthias Kopfermann
          </div>
          <div class="valid">
               <a href="http://jigsaw.w3.org/css-validator/check/referer">
               <img border="0" src="../images/vcss.png" alt="Valid CSS!" width="88" height="31" ></a>&nbsp; 
               <a href="http://validator.w3.org/check/referer">
               <img border="0" src="../images/vali.png" alt="Valid HTML 4.01!" height="31" width="88"></a>
          </div>
        </div>
</body>
</html>

